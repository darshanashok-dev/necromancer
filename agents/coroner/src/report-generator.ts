import { AnalysisResult } from '@necrostack/js-analyzer';
import { AutopsyReport } from './types.js';
import { HealthCalculator } from '@necrostack/js-analyzer';

export class ReportGenerator {
  private healthCalculator = new HealthCalculator();

  generate(analysisResult: AnalysisResult, repositoryInfo: any): AutopsyReport {
    const healthStatus = this.healthCalculator.getStatus(analysisResult.healthScore);

    const report: AutopsyReport = {
      id: this.generateId(),
      timestamp: new Date().toISOString(),
      repository: {
        url: repositoryInfo.url || '',
        name: repositoryInfo.name || '',
        language: analysisResult.projectInfo.language,
        framework: analysisResult.projectInfo.framework,
      },
      health: {
        score: analysisResult.healthScore,
        status: healthStatus,
      },
      findings: {
        deadFiles: analysisResult.deadFiles.map(f => f.path),
        deprecatedDeps: analysisResult.dependencies
          .filter(d => d.isOutdated)
          .map(d => ({
            name: d.name,
            current: d.current,
            latest: d.latest || d.current,
            severity: d.severity || 'low',
          })),
        securityIssues: analysisResult.securityIssues,
        codeSmells: this.detectCodeSmells(analysisResult),
        missingTests: !analysisResult.projectInfo.hasTests,
        testCoverage: analysisResult.metrics.testCoverage || 0,
      },
      architecture: {
        type: this.detectArchitectureType(analysisResult),
        layers: this.detectLayers(analysisResult),
        components: analysisResult.components,
        diagram: '', // Will be generated by DiagramBuilder
      },
      recommendations: this.generateRecommendations(analysisResult),
    };

    return report;
  }

  private generateId(): string {
    return `autopsy-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }

  private detectCodeSmells(result: AnalysisResult): string[] {
    const smells: string[] = [];

    if (result.metrics.avgComplexity > 10) {
      smells.push('High average complexity detected');
    }

    if (result.deadFiles.length > 10) {
      smells.push('Large number of unused files');
    }

    if (result.dependencies.filter(d => d.isOutdated).length > 20) {
      smells.push('Many outdated dependencies');
    }

    if (!result.projectInfo.hasTypeScript) {
      smells.push('No TypeScript - consider migration for better type safety');
    }

    return smells;
  }

  private detectArchitectureType(result: AnalysisResult): string {
    // Simple heuristic based on project structure
    if (result.projectInfo.framework === 'Next.js') {
      return 'monolith';
    }
    return 'monolith';
  }

  private detectLayers(result: AnalysisResult): string[] {
    const layers: string[] = [];

    if (result.projectInfo.framework) {
      if (['Next.js', 'React', 'Vue', 'Angular'].includes(result.projectInfo.framework)) {
        layers.push('frontend');
      }
      if (['Express', 'Fastify', 'NestJS', 'Koa'].includes(result.projectInfo.framework)) {
        layers.push('backend');
      }
    }

    // Check for database
    const hasDatabaseDeps = result.dependencies.some(d =>
      ['prisma', 'mongoose', 'sequelize', 'typeorm', 'pg', 'mysql'].includes(d.name)
    );
    if (hasDatabaseDeps) {
      layers.push('database');
    }

    return layers.length > 0 ? layers : ['frontend'];
  }

  private generateRecommendations(result: AnalysisResult): string[] {
    const recommendations: string[] = [];

    // Security recommendations
    const criticalSecurity = result.securityIssues.filter(i => i.severity === 'critical');
    if (criticalSecurity.length > 0) {
      recommendations.push(`ðŸš¨ Fix ${criticalSecurity.length} critical security issues immediately`);
    }

    // Dependency recommendations
    const outdatedDeps = result.dependencies.filter(d => d.isOutdated);
    if (outdatedDeps.length > 0) {
      recommendations.push(`ðŸ“¦ Update ${outdatedDeps.length} outdated dependencies`);
    }

    // Dead code recommendations
    if (result.deadFiles.length > 0) {
      recommendations.push(`ðŸ—‘ï¸ Remove ${result.deadFiles.length} unused files`);
    }

    // Testing recommendations
    if (!result.projectInfo.hasTests) {
      recommendations.push('ðŸ§ª Add test coverage to improve code quality');
    }

    // TypeScript recommendations
    if (!result.projectInfo.hasTypeScript) {
      recommendations.push('ðŸ“˜ Consider migrating to TypeScript for better type safety');
    }

    // Complexity recommendations
    if (result.metrics.avgComplexity > 10) {
      recommendations.push('ðŸ”§ Refactor complex functions to improve maintainability');
    }

    return recommendations;
  }
}
